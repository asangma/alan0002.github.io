/* jshint forin: false */
define(["../../../core/declare",  "dojo/_base/lang", "dojo/_base/array","dojox/color",
    "dojo/promise/all", "dojo/has",
  "../../layers/LayerView",

  "./i3s/I3SUtil",
  "./i3s/I3SProjectionUtil",
  "./support/LayerViewUpdatingPercentage",

  "../../../Graphic",

  "../support/PromiseLightweight",
  "../support/projectionUtils",

  "../lib/glMatrix",

  "../webgl-engine/Stage",
  "../webgl-engine/lib/Base64Binary",
  "../webgl-engine/lib/Layer",
  "../webgl-engine/lib/Util",
  "../webgl-engine/lib/Geometry",
  "../webgl-engine/lib/GeometryData",
  "../webgl-engine/lib/Object3D",
  "../webgl-engine/materials/Material",
  "../webgl-engine/lib/Texture"
],
  function(declare, lang, dojoArray, dojoxcolor_, all, has,
           LayerView,
           I3SUtil, I3SProjectionUtil, LayerViewUpdatingPercentage,
           EsriGraphic,
           promise,
           projectionUtils,
           glMatrix,
           Stage, Base64Binary, Layer, Util, Geometry, GeometryData, Object3D, Material, Texture) {

    var assert = Util.assert;
    var mat4d = glMatrix.mat4d;
    var vec3 = glMatrix.vec3;
    var clamp = Util.clamp;
    var isPowerOfTwo = Util.isPowerOfTwo;
    var fallbackIfUndefined = Util.fallbackIfUndefined;
    var objectEmpty = Util.objectEmpty;
    var VertexAttrConstants = Util.VertexAttrConstants;

    var DBG = false;
    var DBG_NODE_STATUS_VIS = false;
    var DBG_COOKER_WORKAROUNDS = true; //to circumvent errors in caches generated by beijing cooker. should be removed when cooker fixed!
    var DBG_REFCOUNT = false;
    var DBG_LODSWITCH = false;
    var DBG_CREATE_UNITTEST_DATA = false;
    var DBG_SHOW_CLIPPED_FEATURES = false;

    var ModelContentType = Stage.ModelContentType;

    var DEFAULT_COLOR   = [0.8, 0.8, 0.8];
    var DEFAULT_SPECULAR  = [0.5, 0.5, 0.5];
    var DEFAULT_SHININESS = 64;
    var TEXTURE_LOD_BIAS = 9; // higher number -> lower texture resolution on screen
    var TEXTURE_LOD_THRESHOLD_PIXELSCREENSPACE = 5;

    var dummyGraphic = new EsriGraphic();

    return declare([LayerView, LayerViewUpdatingPercentage], {
      declaredClass: "esri.views.3d.layers.SceneLayerView3D",

      initialize:function(){
        var version = this.get("layer.store.version");

        this.useCompressedTextures = this.view.has("s3tc") && (!has("trident") || version>"1.3");

        this._initGraphicsController();

        this.dbg = false;//layer.dbg;


        this.maxGpuMemory = 1000;
        this.gpuMemoryEstimate = 0;
        this.texMemoryEstimate = 0;
        this.geoMemoryEstimate = 0;

        this.memEstimateTextureAdded = function(engineTex)
        {
          var mem = engineTex.getEstimatedTexMemRequiredMB();
          this.gpuMemoryEstimate += mem;
          this.texMemoryEstimate += mem;
        };
        this.memEstimateTextureRemoved = function(engineTex)
        {
          var mem = engineTex.getEstimatedTexMemRequiredMB();
          this.gpuMemoryEstimate -= mem;
          this.texMemoryEstimate -= mem;
        };

        this.memEstimateGeometryAdded = function(geomData)
        {
          var mem = geomData.estimateGpuMemoryUsage()/1000000;
          this.gpuMemoryEstimate += mem;
          this.geoMemoryEstimate += mem;
        };

        this.memEstimateGeometryRemoved = function(geomData)
        {
          var mem = geomData.estimateGpuMemoryUsage()/1000000;
          this.gpuMemoryEstimate -= mem;
          this.geoMemoryEstimate -= mem;
        };

        this._stage = this.view._stage;
        
        this._matId2Meta = {};
        this._texId2Meta = {};
        this._requestedTexImageIds = {};
        this._nodeId2Meta = {};

        // global material color override from symbol. this is temporary, will be replaced with
        // vertex colors to support per-feature coloring.
        this._colorOverride = null;
        var whiteTextureBuffer = new Uint8Array(8*8*4);
        for (var i = 0; i < whiteTextureBuffer.length; i++) {
          whiteTextureBuffer[i] = 255;
        }
        this._whiteTexture = new Texture(whiteTextureBuffer, "white", { width: 8, height: 8});
        this._stage.add(Stage.ModelContentType.TEXTURE, this._whiteTexture);

        // watch for (symbology) renderer changes
        this._currentRenderer = this.layer.get("renderer");
        this._layerEventHandles = [
          this.layer.watch("renderer", function (newRenderer) { this._currentRenderer = newRenderer; }.bind(this)),
          this.layer.watch("opacity", this._opacityChange.bind(this)),
          this.view.watch("clippingArea", this._clippingAreaChanged.bind(this))
        ];
        this._clippingAreaChanged();

        this._addThisLayerToStage();
        this.setVisibility(!this.get("suspended"));

        // togglable debug flags
        this.debugNodeVis = DBG_NODE_STATUS_VIS;
        this.debugLODVis = false;
      },

      destroy: function() {
        this._stage.remove(Stage.ModelContentType.TEXTURE, this._whiteTexture.getId());
        this._removeThisLayerFromStage();

        var removeHandle = function(handle) {
          handle.remove();
        };
        this._layerEventHandles.forEach(removeHandle);
        if (this._extentEventHandles != null) { this._extentEventHandles.forEach(removeHandle); }

        this._stage = null;
        this._controller.destroy();
        this._matId2Meta = null;
        this._texId2Meta = null;
        this._nodeId2Meta = null;
      },
      isBundleAlreadyAddedToStage: function(node, bundleIdx) {
        var wasPartiallyHidden = false;
        var alreadyLoaded = false;
        if (this._nodeId2Meta[node.id] != null && this._nodeId2Meta[node.id].engineObjectsPerBundle && this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleIdx]) {
           alreadyLoaded = true;
          for (var engObjIdx in this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleIdx]) {
            var engObj = this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleIdx][engObjIdx];
            wasPartiallyHidden = engObj.isPartiallyHidden() || node._numFeaturesLoadedPerBundle < node.features.length;
            if (wasPartiallyHidden) {
              break;
            }
          }
        }
        return {
          wasPartiallyHidden: wasPartiallyHidden,
          alreadyLoaded: alreadyLoaded
        };
      },
      _initGraphicsController: function() {

        var requiredFunctions = {
          addBundle: this._addBundle.bind(this),
          isBundleAlreadyAddedToStage: this.isBundleAlreadyAddedToStage.bind(this),
          isOverMemory: this.isOverMemory.bind(this),
          removeNodeData: this._removeNodeDataFromStage.bind(this),
          removeFeatures: this._removeFeatures.bind(this),
          getAddedFeatures: this._getAddedFeatures.bind(this),
          areAllBundlesLoaded: this._areAllBundlesLoaded.bind(this),
          wholeNodeSwitchEnabled: true
        };

        var optionalFunctions = {
          additionalStartNodeLoadingHandler: this._startNodeLoading.bind(this),
          additionalCancelNodeLoadingHandler: this.cancelNodeLoading.bind(this),
          getTexturePrefetchFunctions: function() {
            return {
              _calcDesiredTextureLOD: this._calcDesiredTextureLOD.bind(this),
              _imageIsPartOfTextureBundle: this._imageIsPartOfTextureBundle.bind(this),
              _matId2Meta: this._matId2Meta,
              _texId2Meta: this._texId2Meta,
              useCompressedTextures: function () { return this.useCompressedTextures; }.bind(this)
            };
          }.bind(this),
          _nodeDebugVisualizer: this._nodeDebugVisualizer,
          setPolygonOffset: this._setPolygonOffset.bind(this),
          traversalOptions: {initDepthFirst:true, neighborhood:true, perLevelTraversal: false, allowPartialOverlaps: false},

          getLoadedAttributes: this.getLoadedAttributes.bind(this),
          setAttributeData: this.setAttributeData.bind(this)
        };

        var graphicsControllerPromise = this.layer.createGraphicsController({layerView: this, layerViewRequiredFunctions: requiredFunctions, layerViewOptionalFunctions:optionalFunctions});
        all([this, graphicsControllerPromise]).then(
          function(data) {
          }.bind(this)
        );
      },

      /* zurich methods */

      setMaxGpuMemory: function(v) {
        this.maxGpuMemory = v;
      },

      setVisibility: function (visible){
        if (this._stage && this._engineLayer) {
          var layerId = this._engineLayer.getId();

          var visibleLayers = this._stage.getViewContent();

          if(visible!==false && visibleLayers.indexOf (layerId) >= 0) { return;}
          if(visible===false && visibleLayers.indexOf (layerId) == -1) { return;}

          var layerIds = [layerId];
          if (this._nodeDebugVisualizer!=null) {
            layerIds.push(this._nodeDebugVisualizer.engineLayer.getId());
          }

          if ( visible!==false ) {
            this._stage.addToViewContent(layerIds);
          }
          else {
            this._stage.removeFromViewContent(layerIds);
          }
        }
      },

      setRemoveEnabled: function(r)
      {
        this.removeEnabled = r;
      },

      getEngineLayer: function(){
        return this._engineLayer;
      },

      getStats: function() {
        var vaName;
        var stats = {
          nodesInIndex: 0,
          knownFeatures: 0,
          displayedFeatures: 0,
          displayedGeometries: 0,
          displayedComponents: 0,
          geometryDataSize: 0
        };
        if (!this._controller) {
          return stats;
        }
        for (var nodeID in this._controller.get("nodeIndex")) {
          if (this._controller.get("nodeIndex").hasOwnProperty(nodeID)) {
            stats.nodesInIndex++;
            var node = this._controller.get("nodeIndex")[nodeID];
            if (node.features==null) {
              continue;
            }
            for (var featureIdx = 0; featureIdx < node.features.length; featureIdx++) {
              var feature = node.features[featureIdx];
              stats.knownFeatures++;
              if (feature.engineObject!=null) {
                stats.displayedFeatures++;
                var geometryRecords = feature.engineObject.getGeometryRecords();
                stats.displayedGeometries += geometryRecords.length;
                for (var geoRecordIdx = 0; geoRecordIdx < geometryRecords.length; geoRecordIdx++) {
                  var data = geometryRecords[geoRecordIdx].geometry.getData();
                  var faces = data.getFaces();
                  stats.displayedComponents += faces.length;
                  for (var geoGroupIdx = 0; geoGroupIdx < faces.length; geoGroupIdx++) {
                    var inds = faces[geoGroupIdx].indices;
                    for (vaName in inds) {
                      if (inds.hasOwnProperty(vaName)) {
                        stats.geometryDataSize += inds[vaName].byteLength;
                      }
                    }
                  }
                  var vertexAttr = data.getVertexAttr();
                  for (vaName in vertexAttr) {
                    if (vertexAttr.hasOwnProperty(vaName)) {
                      stats.geometryDataSize += vertexAttr[vaName].data.byteLength;
                    }
                  }
                }
              }
            }
          }
        }

        stats.activeMaterials = Object.keys(this._matId2Meta).length;

//        stats.activeTextures = Object.keys(this._matId2Meta).length;
//        stats.textureDataSize = Object.keys(this._texId2Meta).length;
//        for (var texID in this._texId2Meta) {
//          var texMeta = this._texId2Meta[texID];
//          if (texMeta.curLOD > -1) {
//            stats.textureDataSize +=
//          }
//        }

        return stats;
      },


      _addThisLayerToStage:function() {
        var stage = this._stage;

        this._initTexture = new Texture(null, "i3sInitTexture");
        stage.add(ModelContentType.TEXTURE, this._initTexture);

        var idHint = this.layer.get("id");
        var layer = new Layer(idHint,
          {
            "fullExtent": projectionUtils.convertExtent(this.layer.fullExtent, this.view.renderSpatialReference),
            "initialExtent": projectionUtils.convertExtent(this.layer.initialExtent, this.view.renderSpatialReference)
          },
          idHint);

        this._engineLayer = layer;

        stage.add(ModelContentType.LAYER, layer);

        if (this._nodeDebugVisualizer != null) {
          this._nodeDebugVisualizer.dispose();
        }
        if (DBG_NODE_STATUS_VIS) {
          this._nodeDebugVisualizer = I3SUtil.makeNodeDebugVisualizer(stage,
            this.view.renderCoordsHelper, idHint);
          window._nodeDebugVisualizer = this._nodeDebugVisualizer;
        }
      },

      _removeThisLayerFromStage:function(){

        this.cancelNodeLoading();

        if (this._engineLayer==null) {
          return;
        }

        var stage = this._stage;

        stage.remove(ModelContentType.TEXTURE, this._initTexture.getId());

        for (var nodeID in this._controller.get("nodeIndex")) {
          if (this._controller.get("nodeIndex").hasOwnProperty(nodeID)) {
            var node = this._controller.get("nodeIndex")[nodeID];
            this._removeNodeDataFromStage(node);
            delete this._controller.get("nodeIndex")[nodeID];
          }
        }

        assert(objectEmpty(this._nodeId2Meta));
        assert(objectEmpty(this._matId2Meta));
        assert(objectEmpty(this._texId2Meta));

        stage.remove(ModelContentType.LAYER, this._engineLayer.getId());

        if (this._nodeDebugVisualizer!=null) {
          this._nodeDebugVisualizer.dispose();
        }
        this._nodeDebugVisualizer = undefined;

        this._matId2Meta = {};
        this._texId2Meta = {};

        this._requestedTexImageIds = {};
        this._nodeId2Meta = {};

        this._engineLayer = undefined;

        this.gpuMemoryEstimate = 0;


      },

      _startNodeLoading: function() {
        this._updateAllTextureLOD();
      },

      cancelNodeLoading: function() {
        if (this._nodeDebugVisualizer!=null) {
          this._nodeDebugVisualizer.clear();
        }
        this._requestedTexImageIds = {};
      },

      _isAllHidden: function(node) {
        for (var engObjIdx in this._nodeId2Meta[node.id].engineObjects) {
          var engObj = this._nodeId2Meta[node.id].engineObjects[engObjIdx];
          if (!engObj.isAllHidden()) {
            return false;
          }
        }
        return true;
      },

      getLoadedAttributes: function (node) {
        var meta = this._nodeId2Meta[node.id];
        if (meta && meta.engineObjects.length == 1)
        {
          return meta.engineObjects[0].getMetadata().loadedAttributes;
        }
      },

      setAttributeData: function (node, loadedAttributes, attributeData) {
        var meta = this._nodeId2Meta[node.id];
        if (meta && meta.engineObjects.length == 1) {
          var obj = meta.engineObjects[0];
          var metadata = obj.getMetadata();
          metadata.loadedAttributes = loadedAttributes;
          metadata.attributeData = attributeData;

          this._setObjectSymbology(obj);
        }
      },

      _createUnitTestData: function(stage) {

        var testData = {};

        var camera = this.view.navigation.targetCamera;
        
        testData.viewParams = {
          eye: camera.eye,
          center: camera.center,
          up: camera.up,
          viewMatrix: camera.viewMatrix,
          projectionMatrix: camera.projectionMatrix,
          fovX: camera.fovX,
          viewport: camera.viewport,
          perPixelRatio: camera.perPixelRatio
        };

        testData.visibleObjects = [];

        var objects = stage.getAll("objects");
        for (var objId in objects) {
          var object = objects[objId];

          if (object.getParentLayer()!==this._engineLayer) {
            continue;
          }

          var meta = object.getMetadata();
          var features = meta.features;
          var nodeId = meta.i3sNode;

          var featureIDs = dojoArray.map(features, function(item){
            return item.id;
          });

          featureIDs.sort();

          var visObj = {featureIDs:featureIDs, nodeId:nodeId};
          testData.visibleObjects.push(visObj);
        }

        console.debug(testData.visibleObjects.length);
        return JSON.stringify(testData);

      },
      isOverMemory: function() {
        if (this.gpuMemoryEstimate>this.maxGpuMemory)
        {
          console.warn("over memory: "+this.gpuMemoryEstimate+" tex "+this.texMemoryEstimate+ " geom "+this.geoMemoryEstimate);
          return true;
        }
        return false;
      },
      _getAddedFeatures: function(nodeId) {
        var meta = this._nodeId2Meta[nodeId];
        if (meta==null) {
          return null;
        }
        var features = [];
        for (var engIdx in this._nodeId2Meta[nodeId].engineObjects) {
          var engObj = this._nodeId2Meta[nodeId].engineObjects[engIdx];
          for (var fIdx in engObj.getMetadata().features) {
            features.push(engObj.getMetadata().features[fIdx]);
          }
        }
        return features;
      },
      _calcEngineMaterialTransparencyParams: function(i3sTex, i3sMatParams, symbolIsTransparent) {
        var layerOpacity = this.layer.get("opacity");
        if (layerOpacity == null) {
          layerOpacity = 1;
        }
        var matOpacity = 1.0 - clamp(fallbackIfUndefined(i3sMatParams.transparency, 0.0), 0.0, 1.0);
        var opacity = layerOpacity*matOpacity;

        // We do not try to do transparency rendering based on the texture or useVertexColors if we forcefully have
        // double sided rendering disabled (debug mode)
        var transparent = (opacity < 1.0) || ((i3sTex && i3sTex.channels.endsWith("a")) || (i3sMatParams.useVertexColorAlpha===true)) || symbolIsTransparent;
        return {opacity: opacity, transparent:transparent};
      },
      _calcEngineMaterialDoubleSidedParams: function(i3sMatParams) {
        return i3sMatParams.doubleSided != null ? i3sMatParams.doubleSided : true;
      },
      _calcEngineMaterialCullFaceParams: function(i3sMatParams) {
        if (i3sMatParams.cullFace) {
          return i3sMatParams.cullFace;
        }
        if (i3sMatParams.doubleSided != null) {
          return i3sMatParams.doubleSided ? "none" : "back";
        }
        return "none";
      },
      _createEngineMaterial : function(i3sTex, i3sTexId, i3sMat, i3sMatId, features, _texId2Meta, _matId2Meta, _initTextureId, preloadedImageData) {

        var engineTexId = _initTextureId;

        // get engineTexId: either existing or use initTexture
        if (i3sTex!=null) {
          var texMeta = _texId2Meta[i3sTexId];
          engineTexId = (texMeta && texMeta.engineTex) ? texMeta.engineTex.getId() : _initTextureId;

        }

        var i3sMatParams = i3sMat.params;
        // build mat parameters
        var i3sMatColor = fallbackIfUndefined(i3sMatParams.diffuse, DEFAULT_COLOR);

        if (i3sTex!=null) {
          var encodingIdx = I3SUtil.getAppropriateTextureEncoding(i3sTex.encoding, this.useCompressedTextures);
          var encoding = (encodingIdx > -1) ? i3sTex.encoding[encodingIdx] : i3sTex.encoding;
        }

        var warnings = "";
        if (i3sMat.type!=="standard")
        {
          warnings+="Unknown material type '"+i3sMatParams.type+"', must be 'standard'";
        }
        if (i3sMatParams.reflectivity===undefined)
        {
          warnings+="Material parameter 'reflectivity' is missing.";
        }
        if (warnings.length>0) {
          this.layer.warningEvent(warnings,1);
        }

        var matParams = {
          ambient : this._colorOverride || i3sMatColor,
          diffuse : this._colorOverride || i3sMatColor,
          specular : fallbackIfUndefined(i3sMatParams.specular, DEFAULT_SPECULAR),
          shininess : fallbackIfUndefined(i3sMatParams.shininess, DEFAULT_SHININESS),
          atlasRegions : i3sMatParams.vertexRegions,
          textureId : (engineTexId && this._colorOverride) ? this._whiteTexture.getId() : engineTexId,
          vertexColors : true, //i3sMatParams.vertexColors,
          flipV: false, //encoding!=null && encoding===Texture.DDS_ENCODING?true:false
          doubleSided: this._calcEngineMaterialDoubleSidedParams(i3sMatParams),
          cullFace: this._calcEngineMaterialCullFaceParams(i3sMatParams)
        };

        var transparency = this._calcEngineMaterialTransparencyParams(i3sTex, i3sMatParams);
        lang.mixin(matParams,transparency);

        // create new engine material
        var engineMat = new Material(matParams);
        engineMat.metadata = {
          i3sMatId : i3sMatId,
          i3sTexId : i3sTexId,
          i3sTex: i3sTex,
          i3sMatParams: i3sMatParams
        };

        // now that we know the material's engine ID, handle texture loading
        if (i3sTex!=null) {
          // setup or fetch metadata for texture
          if (texMeta) {
            texMeta.usedByEngineMats.push(engineMat);
          } else {

            texMeta = {
              id : i3sTexId,
              featureMBS : {},
              usedByEngineMats : [ engineMat ],
              images : i3sTex.images,
              encoding : encoding,
              encodingIdx : encodingIdx,
              atlas : i3sTex.atlas === true,
              wrap : i3sTex.wrap[0] !== "none" || i3sTex.wrap[1] !== "none"
            };
            _texId2Meta[i3sTexId] = texMeta;
          }
          for (var featureIdx=0; featureIdx<features.length; featureIdx++)
          {
            var feature = features[featureIdx];
            texMeta.featureMBS[feature.id] = feature.engineMBS;
          }
          // initiate the loading of a current lod
          if (preloadedImageData[i3sTexId]!==undefined)
          {
            if (texMeta.engineTex==null) {
              var imageDataRec = preloadedImageData[i3sTexId];
              var imageData = imageDataRec.data;
              var params = getTextureParams(imageData, texMeta);
              texMeta.engineTex = new Texture(imageData, texMeta.id, params);
              this._stage.add(ModelContentType.TEXTURE, texMeta.engineTex);
              texMeta.desiredLOD = preloadedImageData[i3sTexId].desiredLOD;
              texMeta.curLOD = texMeta.desiredLOD;
              this.memEstimateTextureAdded(texMeta.engineTex);
            }
            var texId = texMeta.engineTex.getId();
            for (var matIdx = 0; matIdx < texMeta.usedByEngineMats.length; matIdx++) {
              var mat = texMeta.usedByEngineMats[matIdx];
              if (this._colorOverride == null) {
                mat.setParameterValues({textureId: texId});
              }
              mat.metadata.originalTextureId = texId;
            }

            preloadedImageData[i3sTexId].createdTextureForDomImage();
            delete preloadedImageData[i3sTexId];

          }
          else {
            this._updateTextureLOD(texMeta);
          }
        }

        // init refcounts for this new material
        if (!_matId2Meta[i3sMatId]) {
          _matId2Meta[i3sMatId] = {};
        }
        _matId2Meta[i3sMatId][i3sTexId] = {
          engineMat : engineMat,
          refCount : 1
        };


        if (DBG_REFCOUNT) {
          console.debug("new mat " + engineMat.getId());
        }
        return engineMat;
      },

      _createVertexAndIndexArrays:function(geometry, geometryArrayBuffer, sharedResources) {
        var addDefaultVertexColor = true;
        var TypedArrayClass;

        //read vertex attributes. copy data from geometry arrays.
        var vertexAttrIn = geometry.params.vertexAttributes;
        var va = {};
        for (var name in vertexAttrIn) {
          if (vertexAttrIn.hasOwnProperty(name)) {
            if (name === "classification") {
              continue;
            }
            var an = vertexAttrIn[name];
            TypedArrayClass = I3SUtil.valueType2TypedArrayClassMap[an.valueType];
            assert(TypedArrayClass != null, "unsupported vertex attribute value type: " + an.valueType);
            va[name] = {
              data : new TypedArrayClass(geometryArrayBuffer, an.byteOffset, an.count * an.valuesPerElement),
              size : an.valuesPerElement
            };
          }
        }

        if (addDefaultVertexColor && va[VertexAttrConstants.COLOR] == null)
        {
          TypedArrayClass = I3SUtil.valueType2TypedArrayClassMap.UInt8;
          va[VertexAttrConstants.COLOR] = {
            data : new TypedArrayClass(vertexAttrIn.position.count*4),
            size : 4
          };
          for (var i=0; i<va[VertexAttrConstants.COLOR].length; i++)
          {
            va[VertexAttrConstants.COLOR][i] = i%3===0?255:0;
          }
        }

        var addNormals = false;
        if (va[VertexAttrConstants.NORMAL] == null)
        {
          addNormals=true;
          TypedArrayClass = I3SUtil.valueType2TypedArrayClassMap.Float32;
          va[VertexAttrConstants.NORMAL] = {
            data : new TypedArrayClass(vertexAttrIn.position.count*3),
            size : 3
          };
        }

        var regionsVertexBuffer = [];

        //process components. 1) find initial offset for each component index array
        var faces = geometry.params.faces;

        if (faces!=null && geometry.params.topology!="PerAttributeArray") {
          var indicesOffset = {};
          for (name in faces) {
            if (faces.hasOwnProperty(name)) {
              var fn = faces[name];
              assert(fn.count % 3 === 0);
              assert(fn.count === faces.position.count);
              assert(fn.valueType === "UInt32");
              indicesOffset[name] = fn.byteOffset;
            }
          }

          //step through components
          var numComponents = geometry.params.components.length;
          var indexArrays = new Array(numComponents);
          var componentIndices = faces.position.componentIndices;
          for (var compIdx = 0; compIdx < numComponents; compIdx++) {
            var component = geometry.params.components[compIdx];

            var numIndicesInComponent = (compIdx < numComponents - 1) ?
              componentIndices[compIdx + 1] - componentIndices[compIdx] :
              faces.position.count - componentIndices[compIdx];

            //build index arrays for component
            var f = { type: "triangle", positionKey: "position", indices: {}, componentRange:[componentIndices[compIdx],componentIndices[compIdx]+numIndicesInComponent] };
            for (name in faces) {
              if (faces.hasOwnProperty(name)) {
                f.indices[name] = new Uint32Array(geometryArrayBuffer, indicesOffset[name], numIndicesInComponent);
                //increase offsets for next component
                indicesOffset[name] += numIndicesInComponent * 4;
              }
            }

            if (addDefaultVertexColor && f.indices[VertexAttrConstants.COLOR] == null)
            {
              f.indices[VertexAttrConstants.COLOR] = new Uint32Array(numIndicesInComponent);
              for (i=0; i<numIndicesInComponent; i++)
              {
                f.indices[VertexAttrConstants.COLOR][i] = i;
              }
            }

            if (addNormals && f.indices[VertexAttrConstants.NORMAL] == null)
            {
              f.indices[VertexAttrConstants.NORMAL] = new Uint32Array(numIndicesInComponent);
              for (i=0; i<numIndicesInComponent; i++)
              {
                f.indices[VertexAttrConstants.NORMAL][i] = i;
              }
            }

            indexArrays[compIdx] = f;

            //convert old style atlas to new per-vertex one
            //TODO untested, because there was no functioning featureTree cache at time of merge!
            var i3sTexId = component.textureID || "none";
            var i3sTex;
            if (i3sTexId !== "none") {
              i3sTex = sharedResources.textureDefinitions[i3sTexId];
              assert(i3sTex !== undefined, "geometry wants unknown texture " + i3sTexId);
            }
            if (i3sTex && i3sTex.atlas === true && i3sTex.regions!=null) {
              assert(i3sTex.regions.length > 0, "texture marked as atlas carries no region definition");
              var reg = i3sTex.regions[component.regionID].subimageRegion;
              var regionCoords = [reg[0]*65536,(reg[2] - reg[0])*65536, (1.0-reg[3])*65536,(reg[3] - reg[1])*65536];
              regionsVertexBuffer = regionsVertexBuffer.concat(regionCoords);

              var regionsIndexArray = new Uint32Array(numIndicesInComponent);
              for (var k=0; k<numIndicesInComponent; k++) {
                regionsIndexArray[k] = (regionsVertexBuffer.length/4)-1;
              }
              f.indices[VertexAttrConstants.REGION] = regionsIndexArray;
            }
          }
        }
        else {
          //build default arrays
          f = { type: "triangle", positionKey: "position", indices: {}};
          for (var vertexAttr in va) {
            var vertexAttrProps = va[vertexAttr];
            var indexArray = new Uint32Array(vertexAttrProps.data.length/vertexAttrProps.size);
            var indexArrayLength = indexArray.length;
            for (i=0; i<indexArrayLength; i++)
            {
              indexArray[i] = i;
            }
            f.indices[vertexAttr] = indexArray;
          }
          var positionIndices = f.indices[f.positionKey];
          f.componentRange = [0, positionIndices!=null?positionIndices.length-1:0];
          indexArrays = [f];
        }

        if (regionsVertexBuffer.length>0)
        {
          var data = new Uint16Array(regionsVertexBuffer);
          va[VertexAttrConstants.REGION] = {
            data : data,
            size : 4
          };
        }

        return {indexArrays:indexArrays, vertexArrays:va};
      },
      _createEngineMats:function(geometry, features, sharedResources, store, _matId2Meta, _texId2Meta, _initTexture, preloadedDomImages) {

        //step through components
        var numComponents = geometry.params.components.length;
        var engineMats = new Array(numComponents);
        for (var compIdx = 0; compIdx < numComponents; compIdx++) {
          var component = geometry.params.components[compIdx];

          //get material from sharedResources
          var i3sMatId = component.materialID;
          var i3sMat = sharedResources.materialDefinitions[i3sMatId];
          if (i3sMat.href != null) {
            i3sMat = store[i3sMat.hrefConcat].materialDefinitions[i3sMatId];
          }
          assert(i3sMat !== undefined, "geometry wants unknown material " + i3sMatId);

          //get texture from sharedResources
          var i3sTexId = component.textureID || "none";
          var i3sTex;
          if (i3sTexId !== "none") {

            if (sharedResources.textureDefinitions ==null || sharedResources.textureDefinitions[i3sTexId]==null)
            {
              this.layer.warningEvent("textureDefinitions missing in shared resource",1, i3sTexId);
            }

            i3sTex = sharedResources.textureDefinitions[i3sTexId];
          }

          //get or create engine material
          var engineMat;
          if (_matId2Meta[i3sMatId] && _matId2Meta[i3sMatId][i3sTexId]) {
            //already existing? -> reuse, increase refcount
            var matMeta = this._matId2Meta[i3sMatId][i3sTexId];
            engineMat = matMeta.engineMat;
            matMeta.refCount++;
            if (DBG_REFCOUNT) {
              console.debug("reused mat "+engineMat.getId()+", increased refcount "+matMeta.refCount);
            }
          } else {
            engineMat = this._createEngineMaterial(i3sTex,  i3sTexId, i3sMat, i3sMatId, features,
              _texId2Meta,_matId2Meta, _initTexture.getId(),preloadedDomImages);
          }
          engineMats[compIdx] = engineMat;
        }
        return engineMats;
      },
      _areAllBundlesLoaded:function(node, ignoreHiding) {
        if (this._nodeId2Meta[node.id]==null || this._nodeId2Meta[node.id].engineObjectsPerBundle==null) {
          return false;
        }
        for (var i=0; i<node.featureData.length; i++)
        {
          if (this._nodeId2Meta[node.id].engineObjectsPerBundle[i]==null) {
            return false;
          }

          if (ignoreHiding===true) {
            continue;
          }

          for (var engObjIdx in this._nodeId2Meta[node.id].engineObjectsPerBundle[i]) {
            var engObj = this._nodeId2Meta[node.id].engineObjectsPerBundle[i][engObjIdx];
            if (engObj.isPartiallyHidden()) {
             return false;
           }
          }
        }
        return true;
      },
      getGraphicsFromStageObject: function(stageObject, triangleNr) {
        var p = new promise.Promise();
        var metaData = stageObject.getMetadata();
        var faceRangeIndex = stageObject.getFaceRangeIndexFromTriangleNr(triangleNr);

        var layer = this.layer;
        var companionFeatureLayer = layer._companionFeatureLayer;

        //heuristic for attributes:
        //1. if already in graphics (because featureData was already loaded an had attributes), directly take this graphic
        if (faceRangeIndex!=null && metaData.graphics!=null &&  metaData.graphics[0].attributes!=null) {
          p.done(metaData.graphics[faceRangeIndex]);
        }
        else if (faceRangeIndex!=null && metaData.featureIds!=null && metaData.featureIds[faceRangeIndex]!=null) {
          //2. if we have featureIds from the binary geometry data, use them and query companion layer
          var featureId = metaData.featureIds[faceRangeIndex];
          queryAttributesFromFeatureLayer(featureId, p);
        }
        else {
          //3. load feature data document and query companion layer
          var node = this._controller.get("nodeIndex")[metaData.i3sNode];
          if (node==null || node.featureData==null || node.featureData.length!==1) {
            p.reject();
          }
          else {

            var nodeUrl = I3SUtil.getNodeURL(this._controller.getBaseUrl(), node.id);

            var pathComb = I3SUtil.concatUrl(nodeUrl, node.featureData[0].href);
            this._controller.get("streamDataSupplier").request(pathComb,"json").then(function(url, data, docType, metaData) {
              if (data == null || data.featureData == null) {
                p.reject();
                return;
              }
              for (var fIdx = 0; fIdx < data.featureData.length; fIdx++) {
                var f = data.featureData[fIdx];
                for (var gIdx = 0; gIdx < f.geometries.length; gIdx++) {
                  var g = f.geometries[gIdx];
                  if (g.params.faceRange) {
                    if (triangleNr >= g.params.faceRange[0] && triangleNr <= g.params.faceRange[1]) {
                      queryAttributesFromFeatureLayer(f.id, p);
                      return;
                    }
                  }
                }
              }
              p.reject();
            }.bind(this),
            function(err) {
              p.reject();
            });
          }
        }

        function queryAttributesFromFeatureLayer(featureId, resultPromise) {
          I3SUtil.queryAttributesFromFeatureLayer(companionFeatureLayer, featureId).then(
            function(attributes) {
              var graphic = new EsriGraphic(null, null, attributes);
              graphic.layer = layer;
              resultPromise.done(graphic);
            },
            function(err) {
              resultPromise.reject(err);
            }
          );
        }

        return p;
      },

      _calculateNormals: function(indexArrays, vertexArrays) {
          var normal = vertexArrays.normal;
          var position = vertexArrays.position;

          var normalInd = indexArrays[0].indices.normal;
          var positionInd = indexArrays[0].indices.position;

          assert(normalInd.length==positionInd.length);

          var vecTemp1 = vec3.create();
          var vecTemp2 = vec3.create();

          for (var triangleOffset = 0; triangleOffset < positionInd.length; triangleOffset += 3) {
            var vertexOffset = positionInd[triangleOffset+0] * 3;
            var x = position.data[vertexOffset+0];
            var y = position.data[vertexOffset+1];
            var z = position.data[vertexOffset+2];
            vertexOffset = positionInd[triangleOffset+1] * 3;
            vecTemp1[0] = position.data[vertexOffset+0] - x;
            vecTemp1[1] = position.data[vertexOffset+1] - y;
            vecTemp1[2] = position.data[vertexOffset+2] - z;
            vertexOffset = positionInd[triangleOffset+2] * 3;
            vecTemp2[0] = position.data[vertexOffset+0] - x;
            vecTemp2[1] = position.data[vertexOffset+1] - y;
            vecTemp2[2] = position.data[vertexOffset+2] - z;

            vec3.cross(vecTemp1, vecTemp2, vecTemp1);
            vec3.normalize(vecTemp1);

            for (var i=0; i<3; i++) {
              var normalOffest = normalInd[triangleOffset+i] * 3;
              normal.data[normalOffest+0] = vecTemp1[0];
              normal.data[normalOffest+1] = vecTemp1[1];
              normal.data[normalOffest+2] = vecTemp1[2];
            }
        }
      },
      _addBundle:function(node, allGeometryData, attributeDataInfo, store, promiseLoaded, preloadedDomImages, bundleNr) {

        if (this.debugNodeVis===true && this._nodeDebugVisualizer!=null) {
          var color = "grey";
          switch (node.level) {
            case 1: color = "red";break;
            case 2: color = "green";break;
            case 3: color = "blue";break;
            case 4: color = "yellow";break;
            case 5: color = "magenta";break;
            case 6: color = "brown";break;
          }

          this._nodeDebugVisualizer.show(node, this._controller._crsIndex, color);
        }


        var stage = this._stage;
        var changes = {};
        changes[ModelContentType.OBJECT] = {};
        changes[ModelContentType.GEOMETRY] = {};
        changes[ModelContentType.MATERIAL] = {};
        changes[ModelContentType.TEXTURE] = {};

        var layer = this._engineLayer;
        var layerId = layer.getId();

        var sharedResources = store[node.sharedResource.hrefConcat];

        if (this._nodeId2Meta[node.id]!=null && this._nodeId2Meta[node.id].engineObjectsPerBundle!=null && this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleNr])
        {
          for (var engObjIdx in this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleNr]) {
            var engObj = this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleNr][engObjIdx];
            this._hideFaceRangesOutsideBoundingBox(node, this._clippingArea);
          }
          if (promiseLoaded!=null) {
            promiseLoaded.done();
          }
          return;
        }

        if (this.isOverMemory()) {
          return;
        }

        if (this._nodeId2Meta[node.id]==null || this._nodeId2Meta[node.id].engineObjectsPerBundle==null) {
          this._nodeId2Meta[node.id] = {};
          this._nodeId2Meta[node.id].engineObjects = [];
          this._nodeId2Meta[node.id].engineObjectsPerBundle = [];
        }
        this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleNr] = [];

        if (DBG_CREATE_UNITTEST_DATA) {
          if (this.allUnitTestData==null) {
            this.allUnitTestData = {};
          }
        }

        if (allGeometryData==null) {
          if (promiseLoaded != null) {
            promiseLoaded.done();
          }
          return;
        }

        for (var i=0; i<allGeometryData.length; i++) {
          var geometries = allGeometryData[i].geometries;
          var features = allGeometryData[i].features;
          var featureDataAttributes = allGeometryData[i].featureDataAttributes;

          var geometryArrayBuffer = store[node.geometryData[bundleNr].hrefConcat];
          assert(geometryArrayBuffer instanceof ArrayBuffer, "I3S: geometry data is not an ArrayBuffer");

          if (geometryArrayBuffer._isReprojected==null) {
            geometryArrayBuffer._isReprojected={};
          }

          var objectName = features[0].id.toString();

          var objectGeometries = [];
          var objectGeometryTransformations = [];
          var objectMaterials = [];

          for (var geomIdx = 0; geomIdx < geometries.length; ++geomIdx) {
            var geometry = geometries[geomIdx];

            if (DBG_REFCOUNT) {
              console.debug("adding geometry " + geomIdx);
            }

            var via = this._createVertexAndIndexArrays(geometry, geometryArrayBuffer, sharedResources);

            if (DBG_COOKER_WORKAROUNDS && (via.indexArrays.length === 0)) {
              // current cookers seem to produce geometries with 0 components, which cause an exception
              // down the road if not caught
              continue;
            }

            var engineMats = this._createEngineMats(geometry, features, sharedResources, store, this._matId2Meta, this._texId2Meta, this._initTexture, preloadedDomImages);

            //setup additional infos for this geometry, needed for object creation

            if (DBG_CREATE_UNITTEST_DATA) {
              var unitTestData = {};
              unitTestData.inputPositions = Base64Binary.encode(via.vertexArrays.position.data);
            }

            //possible types: PER_VERTEX, BOUNDINGBOX, NO_REPROJECTION

            var isReprojected = geometryArrayBuffer._isReprojected[geometry.id];

            var reprojType = this._controller.isMeshPyramid ? I3SProjectionUtil.ReprojectionTypes.PER_VERTEX :
              I3SProjectionUtil.ReprojectionTypes.BOUNDINGBOX;
            var corMatrices = I3SProjectionUtil.reprojectPoints(reprojType, via.vertexArrays.position, via.vertexArrays.normal,
              node.mbs, isReprojected, this._controller.get("crsIndex"), this._controller.get("crsVertex"),
              this.view.renderSpatialReference);

            geometryArrayBuffer._isReprojected[geometry.id] = true;

            if (this._controller.isMeshPyramid) {
              this._calculateNormals(via.indexArrays, via.vertexArrays);
            }


            if (DBG_CREATE_UNITTEST_DATA) {
              unitTestData.perVertexReprojectedPositions = Base64Binary.encode(via.vertexArrays.position.data);
              unitTestData.matrices = corMatrices;
              unitTestData.mbs = node.mbs;
              unitTestData.crsIndex = this._controller.get("crsIndex");
              unitTestData.crsVertex = this._controller.get("crsVertex");
              unitTestData.crsEngine = this.view.renderSpatialReference;
            }

            var modelTrafo = mat4d.create(geometry.transformation);
            mat4d.multiply(corMatrices.localTrafo,modelTrafo, modelTrafo);

            for (var j=0; j<engineMats.length; j++) {
              var engineMat = engineMats[j];
              changes[ModelContentType.MATERIAL][engineMat.getId()] = engineMat;
            }
            //create stage geometry
            var geom = new Geometry(new GeometryData(via.indexArrays, via.vertexArrays),
                objectName + "_" + geomIdx);
            this.memEstimateGeometryAdded(geom.getData());
            changes[ModelContentType.GEOMETRY][geom.getId()] = geom;

            objectGeometries[geomIdx] = geom;
            objectGeometryTransformations[geomIdx] = modelTrafo;
            objectMaterials[geomIdx] = engineMats;

            if (DBG_CREATE_UNITTEST_DATA) {
              this.allUnitTestData[geom.getId()] = unitTestData;
            }

          }

          //read metadata
          var metadata = {};
          metadata.attributes = {};


          //TODO symbology
          metadata.graphics = [];
          for (var fIdx=0; fIdx<features.length; fIdx++)
          {
            var attributes = featureDataAttributes[fIdx]; //todo in MP we might not have loaded featureData at this point!!
           // var esriGeom = new EsriPoint(feature.mbs[0],feature.mbs[1],feature.mbs[2],this._controller.getCrsIndex());
            var graphic = new EsriGraphic(undefined, undefined, attributes, undefined); //geometry, symbol, attributes, popupTemplate
            graphic.set("layer", this.layer);
            metadata.graphics.push(graphic);
          }


          //add debug metadata
          metadata.i3sNode = node.id;
          metadata.ceLayer = layerId;
          metadata.features = features;
          metadata.faceRanges = allGeometryData[i].faceRanges;
          metadata.featureIds = allGeometryData[i].featureIds;
          metadata.attributeData = attributeDataInfo ? attributeDataInfo.attributeData : null;
          metadata.loadedAttributes = attributeDataInfo ? attributeDataInfo.loadedAttributes : null;
          metadata.layerId = this.layer.id;


          //finally, create engine object consisting of all components
          var object = new Object3D({
            name: objectName,
            geometries: objectGeometries,
            materials: objectMaterials,
            transformations: objectGeometryTransformations,
            castShadow: true,
            metadata: metadata
          });

          var worldTransf = mat4d.create();
          mat4d.identity(worldTransf);

          mat4d.multiply(worldTransf,corMatrices.globalTrafo,worldTransf);

          object.setObjectTransformation(worldTransf);
          this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleNr].push(object);
          this._nodeId2Meta[node.id].engineObjects.push(object);
          changes[ModelContentType.OBJECT][object.getId()] = object;

          this._setObjectSymbology(object);

          if (this._clippingArea != null) {
            this._hideFaceRangesOutsideBoundingBox(node, this._clippingArea);
          }

        }

        if (DBG_LODSWITCH) {
          features="";
          for (engObjIdx in this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleNr]) {
            engObj = this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleNr][engObjIdx];
            for (fIdx in engObj.getMetadata().features) {
              features += "f " + engObj.getMetadata().features[fIdx].id + " rf " + engObj.getMetadata().features[fIdx].rootFeature + ", ";
            }
          }
          console.debug("_addNodeDataToStage node "+node.id+" bundle "+bundleNr+" features "+features);
        }


        if (DBG)
        {
          var countKeys = function(obj) {
            return Object.keys(obj).length;
          };

          console.log("objs: "+countKeys(changes[ModelContentType.OBJECT])+
            " geoms: "+countKeys(changes[ModelContentType.GEOMETRY])+
            " mats: "+countKeys(changes[ModelContentType.MATERIAL])+
            " texts: "+countKeys(changes[ModelContentType.TEXTURE]));
        }


        //add all changes to stage        
        stage.beginMod();
        var newObjects = changes[ModelContentType.OBJECT];
        for (var name in newObjects) {
          if (newObjects.hasOwnProperty(name)) {
            layer.addObject(newObjects[name]);
          }
        }
        for (var contentType in changes) {
          if (changes.hasOwnProperty(contentType)) {
            var toAdd = changes[contentType];
            for (name in toAdd) {
              if (toAdd.hasOwnProperty(name)) {
                if (stage.get(contentType, name) != null) {
                  continue;
                }
                stage.add(contentType, toAdd[name]);
              }
            }
          }
        }
        stage.endMod();

        if (promiseLoaded!=null) {
          promiseLoaded.done();
        }
      },
      _visualizeNode: function(nodeId) {
        if (this._controller.get("nodeIndex")[nodeId]==null) {
          return;
        }
        if (this._nodeDebugVisualizer!=null) {
          this._nodeDebugVisualizer.show(this._controller.get("nodeIndex")[nodeId], "green");
        }

      },

      _clippingAreaChanged: function() {
        var bb = [];
        if (projectionUtils.extentToBoundingBox(this.view.clippingArea, bb, this.view.renderSpatialReference)) {
          this._clippingArea = bb;
        } else {
          this._clippingArea = null;
        }

        var nodeIndex = this._controller && this._controller.nodeIndex;
        if (nodeIndex != null) {
          var self = this;
          Object.keys(this._nodeId2Meta).forEach(function (id) {
            self._hideFaceRangesOutsideBoundingBox(nodeIndex[id], self._clippingArea);
          });
        }
      },

      _hideFaceRangesOutsideBoundingBox: function(node, aabb) {
        if (!this._nodeId2Meta[node.id] || this._nodeId2Meta[node.id].engineObjects == null) {
          return;
        }

        // check node bounding sphere
        var renderMbs = [0,0,0,0];
        projectionUtils.mbsToMbs(node.mbs, this._controller.crsIndex, renderMbs, this.view.renderSpatialReference);
        var intersection = aabb != null ? I3SUtil.intersectBoundingBoxWithMbs(aabb, renderMbs) : 2;
        if (intersection === 0) {
          // completely outside
          for (var engObjIdx in this._nodeId2Meta[node.id].engineObjects) {
            var object = this._nodeId2Meta[node.id].engineObjects[engObjIdx];
            object.hideAllFaceRanges();
          }
          return;
        }
        else if (intersection === 2 ) {
          // completely inside
          aabb = null; // no extent checks necessary
        }

        for (var engObjIdx in this._nodeId2Meta[node.id].engineObjects) {
          var object = this._nodeId2Meta[node.id].engineObjects[engObjIdx];

          //TODO this might break featueTree per-feature-lod visibility, depending on order!
          //we would need to keep track of two facerange arrays (lod and extent), and merge them
          object.unhideAllFaceRange();

          if (aabb == null) {
            continue;
          }

          // transform extent to local coordinates
          var matObj = object.getObjectTransformation();
          var matGeo = object.getGeometryRecords()[0].transformation;
          mat4d.multiply(matObj, matGeo);
          if (                   matObj[1] !== 0 || matObj[2] !== 0 || matObj[3] !== 0 ||
              matObj[4] !== 0 ||                    matObj[6] !== 0 || matObj[7] !== 0 ||
              matObj[8] !== 0 || matObj[9] !== 0 ||                    matObj[11]!== 0 ||
                                                                       matObj[15]!== 1) {
            continue; // only diagonal matrices are supported.
          }
          var xmin_extent = (aabb[0]-matObj[12]) / matObj[ 0];
          var ymin_extent = (aabb[1]-matObj[13]) / matObj[ 5];
          var zmin_extent = (aabb[2]-matObj[14]) / matObj[10];
          var xmax_extent = (aabb[3]-matObj[12]) / matObj[ 0];
          var ymax_extent = (aabb[4]-matObj[13]) / matObj[ 5];
          var zmax_extent = (aabb[5]-matObj[14]) / matObj[10];

          var geometryData = object.getGeometryRecords()[0].geometry.getData();

          var indexArray = geometryData.getFaces()[0].indices.position;
          var vertexArray = geometryData.getVertexAttr().position.data;

          var faceRangesToDelete = [];

          var objFaceRanges = object.getMetadata().faceRanges;

          var xmin, ymin, zmin, xmax, ymax, zmax;

          for (var frIdx=0; frIdx <objFaceRanges.length; frIdx+=1) {
            var faceRange = objFaceRanges[frIdx];
            var begin = faceRange[0];
            var end = faceRange[1];
            // compute bounding box
            xmin = ymin = zmin = Number.MAX_VALUE;
            xmax = ymax = zmax = -Number.MAX_VALUE;
            // loop over all faces
            for (var fIdx = begin; fIdx <= end; fIdx += 1) {
              // loop over all vertices
              for (var vIdx=0; vIdx<3; vIdx+=1) {
                var vOffset = indexArray[fIdx*3+vIdx]*3;
                var vx = vertexArray[vOffset+0];
                var vy = vertexArray[vOffset+1];
                var vz = vertexArray[vOffset+2];

                xmin = Math.min(vx, xmin);
                ymin = Math.min(vy, ymin);
                zmin = Math.min(vz, zmin);
                xmax = Math.max(vx, xmax);
                ymax = Math.max(vy, ymax);
                zmax = Math.max(vz, zmax);
              }
            }

            // intersect bounding box
            var separated =
                xmin > xmax_extent || xmax < xmin_extent ||
                ymin > ymax_extent || ymax < ymin_extent ||
                zmin > zmax_extent || zmax < zmin_extent;

            if (separated) {
              faceRangesToDelete.push(faceRange);
            }
          }
          if (faceRangesToDelete.length>0) {
            if (DBG_SHOW_CLIPPED_FEATURES) {
              this._setObjectSymbology(object);
              object.setFacerangeColors(faceRangesToDelete.map(function(fr){return{faceRanges:fr, color:[0,0,0,0]};}));
            } else {
              object.hideFaceRange(object.getGeometryRecords()[0], faceRangesToDelete);
            }
          }
        }
      },

      _hideFeatures: function(node, featureFilter) {


        for (var engObjIdx in this._nodeId2Meta[node.id].engineObjects) {

            var object = this._nodeId2Meta[node.id].engineObjects[engObjIdx];

            var faceRangesToDelete = [];

            var objFeatures = object.getMetadata().features;
            var objFaceRanges = object.getMetadata().faceRanges;
            for (var ffIdx=0;ffIdx<featureFilter.length;ffIdx++) {
              var featureFF = featureFilter[ffIdx];
              for (var foIdx=0;foIdx<objFeatures.length;foIdx++) {
                if (featureFF===objFeatures[foIdx].id)
                 {
                   if (objFaceRanges!=null && object.getGeometryRecords().length==1) {
                      //faceranges only supported objects with one geometry
                      faceRangesToDelete.push(objFaceRanges[foIdx]);
                   }
                   else
                   {
                     object.hideAllFaceRanges();
                   }
                 }
              }
            }

            if (faceRangesToDelete.length>0) {
              object.hideFaceRange(object.getGeometryRecords()[0], faceRangesToDelete);
            }
          }

      },

      _removeFeatures: function(node, features) {
        if (this._nodeId2Meta[node.id]==null) {
          return;
        }
        this._hideFeatures(node, features);
        if (this._isAllHidden(node) === true) {
          if (DBG_LODSWITCH) {
            console.debug("all hidden for node " + node.id + ". removing.");
          }
          this._removeNodeDataFromStage(node);
        }
      },

      _removeNodeDataFromStage: function(node) {
        if (this._nodeId2Meta[node.id]==null || this._nodeId2Meta[node.id].engineObjects==null) {
          return;
        }

        var stage = this._stage;
        var layer = this._engineLayer;

        for (var engObjIdx = 0; engObjIdx < this._nodeId2Meta[node.id].engineObjects.length; ++engObjIdx) {

            var object = this._nodeId2Meta[node.id].engineObjects[engObjIdx];

            layer.removeObject(object);

            var geoRecords = object.getGeometryRecords();

            for (var geoRecordIdx = 0; geoRecordIdx < geoRecords.length; geoRecordIdx++) {

              var geoRecord = geoRecords[geoRecordIdx];

              this.memEstimateGeometryRemoved(geoRecord.geometry.getData());
              stage.remove(ModelContentType.GEOMETRY, geoRecord.geometry.getId());

              for (var j = 0; j < geoRecord.materials.length; j++) {
                    var mat = geoRecord.materials[j];
                    var engineMatId = mat.getId();

                    var i3sMatId = mat.metadata.i3sMatId;
                    var i3sTexId = mat.metadata.i3sTexId || "none";
                    var matMeta = this._matId2Meta[i3sMatId][i3sTexId];

                    assert(matMeta.refCount > 0);
                    matMeta.refCount--;
                    if (DBG_REFCOUNT) {
                      console.debug("decreased refcount material " + engineMatId + " feature " + geoRecord.geometry._dbgFeature +
                      " geometry " + geoRecordIdx + ", count " + matMeta.refCount);
                    }
                    if (matMeta.refCount === 0) {
                      this._removeMaterial(engineMatId, i3sTexId, i3sMatId, mat, stage);
                }
              }
            }
            stage.remove(ModelContentType.OBJECT, object.getId());

          }
          delete this._nodeId2Meta[node.id];
      },
      
      _removeMaterial:function(engineMatId, i3sTexId, i3sMatId, mat,stage) {

        stage.remove(ModelContentType.MATERIAL, engineMatId);

        if (i3sTexId !== "none") {
          var texMeta = this._texId2Meta[i3sTexId];

          // remove reference to this material from texId -> MatId index
          var texMats = texMeta.usedByEngineMats;
          var texMatsIdx = texMats.indexOf(mat);
          assert(texMatsIdx > -1);
          texMats[texMatsIdx] = texMats[texMats.length - 1];
          texMats.pop();

          // TODO: remove featureMBS

          if (texMats.length < 1) {
            var engineTex = texMeta.engineTex;
            if (engineTex && (engineTex !== this._initTexture)) {
              this.memEstimateTextureRemoved(engineTex);
              stage.remove(ModelContentType.TEXTURE, texMeta.engineTex.getId());
            }
            texMeta.engineTex = undefined;
            texMeta.desiredLOD = -1;
            texMeta.curLOD = -1;
            delete this._texId2Meta[i3sTexId];
          }
        }

        delete this._matId2Meta[i3sMatId][i3sTexId];
        if (objectEmpty(this._matId2Meta[i3sMatId])) {
          delete this._matId2Meta[i3sMatId];
        }      
      },
      _updateAllTextureLOD: function() {
        for (var texId in this._texId2Meta) {
          if (this._texId2Meta.hasOwnProperty(texId)) {
            var texMeta = this._texId2Meta[texId];
            this._updateTextureLOD(texMeta);
          }
        }
      },

      _calcDesiredTextureLOD : function(featuresMBS, images) {
      // determine desired texture LOD based on the projected screen size of all
      // features that
      // use this texture

      //TODO HACK disabled for now because of strange pixelInWorldUnits from cooker
      if (true || images[0].pixelInWorldUnits == null || images[0].pixelInWorldUnits===0) {

        //fallback version using mbs radii for selection
        var maxScreenSize = 0;
        for (var fId in featuresMBS) {
          if (featuresMBS.hasOwnProperty(fId)) {
            var mbs = featuresMBS[fId];
            var worldSize = 2 * mbs[3];
            var screenSize = worldSize / vec3.dist(mbs, this._controller.get("camPos")) * this._controller.get("screenSizeFactor");
            if (screenSize > maxScreenSize) {
              maxScreenSize = screenSize;
            }
          }
        }
        maxScreenSize /= TEXTURE_LOD_BIAS;
        var desiredTextureLOD = images.length - 1; // initialize with coarsest LOD
        while ((desiredTextureLOD > 0) && (images[desiredTextureLOD].size < maxScreenSize)) {
          desiredTextureLOD--;
        }
      }
      else
      {
        var minDist = Number.MAX_VALUE;

        for (fId in featuresMBS) {
          if (featuresMBS.hasOwnProperty(fId)) {
            mbs = featuresMBS[fId];
            var dist = vec3.dist(mbs, this._controller.get("camPos"));
            if (dist<minDist) {
              minDist = dist;
            }
          }
        }

        var screenSizeFactor = (1.0 / minDist) * this._controller.get("screenSizeFactor");

        desiredTextureLOD = images.length - 1; // initialize with coarsest LOD
        while ((desiredTextureLOD > 0)) {
          var pixelInSS = images[desiredTextureLOD].pixelInWorldUnits*screenSizeFactor;
          if (pixelInSS<TEXTURE_LOD_THRESHOLD_PIXELSCREENSPACE) {
            break;
          }
          desiredTextureLOD--;
        }

      }

      return desiredTextureLOD;
    },
    

    _updateTextureLOD : function(texMeta) {
      texMeta.desiredLOD = this._calcDesiredTextureLOD(texMeta.featureMBS, texMeta.images);

      var swap = (texMeta.curLOD !== texMeta.desiredLOD) && ((texMeta.curLOD < 0) || (!texMeta.curLOD) || (texMeta.desiredLOD === 0) || (texMeta.desiredLOD > texMeta.curLOD) || (texMeta.desiredLOD < texMeta.curLOD - 1));
      if (swap) {
        if ( texMeta.images.length===0) {
          return;
        }
        
        var desiredImage = texMeta.images[texMeta.desiredLOD];
        var desiredURL = (texMeta.encodingIdx > -1) ? desiredImage.hrefConcat[texMeta.encodingIdx] : desiredImage.hrefConcat;

        if (!this._requestedTexImageIds[desiredImage.id]) {
          var requestOptions = {
            metadata : {
              texMeta : texMeta,
              image : desiredImage
            }
          };
          this._requestedTexImageIds[desiredImage.id] = true;
          if (this._imageIsPartOfTextureBundle(desiredImage)) {
            this._controller.get("streamDataSupplier").request(desiredURL, "binary", requestOptions).then(this._extractTextureImageFromBlob, null, this);
          }
          else {
            this._controller.get("streamDataSupplier").request(desiredURL, "image", requestOptions).then(
              function(url, data, docType, meta) {
                this._textureImageLoaded(url, data, meta.image, meta.texMeta);
              }.bind(this)
            );
          }
        }
      }

      if (!texMeta.engineTex) {
        texMeta.engineTex = this._initTexture;
        texMeta.curLOD = -1;
      }

      if (this.debugLODVis) {
        var col = dojoxcolor_.fromHsv(texMeta.desiredLOD / texMeta.images.length * 270, 100, 100);
        col = col.toRgb();
        col = col.map(function(c) {
          return c / 255;
        });
        for (var i = 0; i < texMeta.usedByEngineMats.length; i++) {
          var engineMat = texMeta.usedByEngineMats[i];
          var matParams = {
            ambient : col,
            diffuse : col
          };
          engineMat.setParameterValues(matParams);
        }
      }
    },

      _extractTextureImageFromBlob: function(url, data, docType, meta) {
        // reality check: do we still want this texture LOD?
        var texMeta = meta.texMeta;
        if ((texMeta.desiredLOD < 0) || (meta.image.size > texMeta.images[texMeta.desiredLOD].size)) {
          delete this._requestedTexImageIds[meta.image.id];
          return;
        }

        var that = this;
        assert(docType === "binary");
        var blobUrl;

        try {
          var byteOffset, length;
          if (texMeta.encodingIdx > -1) {
            byteOffset = meta.image.byteOffset[texMeta.encodingIdx];
            length = meta.image.length[texMeta.encodingIdx];
          }
          else {
            byteOffset = meta.image.byteOffset;
            length = meta.image.length;
          }
          var textureArray = new Uint8Array(data, byteOffset,length);
          var blob = new Blob([textureArray], {type: texMeta.encoding});
          blobUrl = window.URL.createObjectURL(blob);
        }
        catch (e) {
          //red error image
          blobUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIElEQVQ4T2P8zyD6n4ECwDhqAMNoGDCMhgEwDw2DdAAAdzkhQdS8dl8AAAAASUVORK5CYII=";
          console.error("error loading texture "+url+" "+e);
        }

        var domImage = new Image();

        domImage.onerror = function() {
          window.URL.revokeObjectURL(blobUrl);
          domImage.url = "";
          domImage.onerror = undefined;
          domImage.onload = undefined;
        };

        domImage.onload = function() {
          //that._textureImageLoaded(url, domImage, meta.image, meta.texMeta);
          that._controller.queueAnimationFrameFunctionCall(that._textureImageLoaded, that,
            [url, domImage, meta.image, meta.texMeta, blobUrl], undefined, 1);
          window.URL.revokeObjectURL(blobUrl);
          domImage.url = "";
          domImage.onerror = undefined;
          domImage.onload = undefined;
        };

        domImage.src = blobUrl;
      },

      _textureImageLoaded: function(url, domImage, i3sImage, texMeta, blobUrl) {
        delete this._requestedTexImageIds[i3sImage.id];
        if (texMeta.desiredLOD < 0) {
          return;
        }
        var desiredImage = texMeta.images[texMeta.desiredLOD];
        var curImage = texMeta.images[texMeta.curLOD]; // curLOD can be -1 -> curImage === undefined
        // we're going to use this texture LOD if
        // - we don't currently have a texture loaded, or
        // - it is larger than the current texture LOD but smaller or equal to the desired LOD (upgrade), or
        // - it is smaller than the current LOD and larger or equal to the desired LOD (downgrade)

        if (this.isOverMemory() && (curImage==null || i3sImage.size > curImage.size)) {
            return;
        }

        if (!curImage ||
          ((i3sImage.size > curImage.size) && (i3sImage.size <= desiredImage.size)) ||
          ((i3sImage.size < curImage.size) && (i3sImage.size >= desiredImage.size))) {

          var engineTex = texMeta.engineTex;
          if (engineTex && (engineTex !== this._initTexture)) {
            this.memEstimateTextureRemoved(engineTex);
            this._stage.remove(ModelContentType.TEXTURE, texMeta.engineTex.getId());
          }

          var params = getTextureParams(domImage, texMeta);
          texMeta.engineTex = new Texture(domImage, texMeta.id, params);
          this._stage.add(ModelContentType.TEXTURE, texMeta.engineTex);
          texMeta.curLOD = texMeta.desiredLOD;
          this.memEstimateTextureAdded(texMeta.engineTex);

          var texId = texMeta.engineTex.getId();
          for (var i = 0; i < texMeta.usedByEngineMats.length; i++) {
            var engineMat = texMeta.usedByEngineMats[i];
            if (this._colorOverride == null) {
              engineMat.setParameterValues({textureId: texId});
            }
            engineMat.metadata.originalTextureId = texId;
          }

          if (i3sImage !== desiredImage) {
            texMeta.curLOD = texMeta.images.indexOf(i3sImage);
            assert(texMeta.curLOD > -1);
            if (!this._requestedTexImageIds[desiredImage.id]) {
              var requestOptions = {metadata: {texMeta: texMeta, image: desiredImage}};
              this._requestedTexImageIds[desiredImage.id] = true;
              this._controller.get("streamDataSupplier").request(desiredImage.hrefConcat, "binary", requestOptions)
                .then(this._extractTextureImageFromBlob, null, this);
            }
          }
        }
      },

      _imageIsPartOfTextureBundle: function(image) {
        // TODO: query node.textureData.*.multiTextureBundle
        return !this._controller.get("isMeshPyramid");
      },



      _setPolygonOffset: function(node, po) {
        // assumes materials are unique to this node
        var bundleNr, engObjIdx, engObj;
        if (this._nodeId2Meta[node.id]!=null && this._nodeId2Meta[node.id].engineObjectsPerBundle!=null) {
          for (bundleNr = 0; bundleNr < this._nodeId2Meta[node.id].engineObjectsPerBundle.length; bundleNr++) {
            for (engObjIdx in this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleNr]) {
              engObj = this._nodeId2Meta[node.id].engineObjectsPerBundle[bundleNr][engObjIdx];
              for (var geomRecIdx = 0; geomRecIdx < engObj.getGeometryRecords().length; geomRecIdx++) {
                var geomRec = engObj.getGeometryRecords()[geomRecIdx];
                for (var matIdx = 0; matIdx < geomRec.materials.length; matIdx++) {
                  var mat = geomRec.materials[matIdx];
                  mat.setParameterValues({polygonOffset: po});
                }
              }
            }
          }
        }
      },


      _getRenderer: function(graphic) {
        if (!graphic || graphic.symbol) {
          return null;
        }
        
        var effective = this._rndForScale || this._currentRenderer;
        if (graphic && effective && effective.getObservationRenderer) {
          effective = effective.getObservationRenderer(graphic);
        }

        return effective;
      },

      _getSymbol: function(graphic) {
        if (graphic.symbol) {
          return graphic.symbol;
        }
        var rnd = this._getRenderer(graphic);
        return rnd && rnd.getSymbol(graphic);
      },

      _getRenderingInfo: function(graphic) {
        var renderer = this._getRenderer(graphic),
          symbol = this._getSymbol(graphic),
          renderingInfo;

        if (!symbol) {
          return null;
        }

        renderingInfo = {
          symbol: symbol
        };

        if (renderer) {
          if (renderer.colorInfo || renderer.sizeInfo) {
            console.warn("renderer.colorInfo and renderer.sizeInfo are not supported for Scene Services. Use visualVariables instead.");
          }
          if (renderer.visualVariables) {
            // Override renderingInfo.color with visual variables.
            var visualVariables = renderer.getVisualVariableValues(graphic);
            for (var vvIdx = 0; vvIdx < visualVariables.length; vvIdx++) {
              var visualVariable = visualVariables[vvIdx];
              var type = visualVariable.variable.type;
              if (type === "colorInfo") {
                renderingInfo.color = visualVariable.value;
              }
            }
          }
        }
        if (renderingInfo && renderingInfo.color) {
          var c = renderingInfo.color;
          renderingInfo.color = [c.r/255, c.g/255, c.b/255, c.a];
        }
        return renderingInfo;
      },

      _setObjectSymbology: function(obj) {
        var meta = obj.getMetadata();

        var faceRangeColors = [];

        var graphics = meta.graphics;

        var setMaterialTransparent = false;

        var numGraphics = graphics.length,
          numFeatures = meta.faceRanges ? meta.faceRanges.length : numGraphics;

        // fake graphic to pass to _getRenderingInfo because creating
        // a graphic for every feature is too expensive.
        // TODO: do we need other properties in the dummy graphic?
        var graphic = { attributes: {}};

        for (var featIdx = 0; featIdx < numFeatures; featIdx++) {

          if (numFeatures === numGraphics && meta.attributeData == null) {
            graphic = graphics[featIdx]; // if we have a one to one mapping from feature to graphic
          } else {
            // copy attributes from metadata
            Object.keys(meta.attributeData).forEach(function(attributeName) {
              graphic.attributes[attributeName] = meta.attributeData[attributeName][featIdx];
            });
          }

          var renderingInfo = this._getRenderingInfo(graphic);

          //TODO Switch material to +vertexcolor if not yet?
          //for now: already create all materials with vertex colors!

          var fr = meta.faceRanges!=null?meta.faceRanges[featIdx]:null;
          if (renderingInfo) {
            var color = renderingInfo.color ;
            if (color==null && renderingInfo.symbol!=null)
            {
              var symbolColor = renderingInfo.symbol.symbolLayers[0].material.color;
              color = [symbolColor.r/255, symbolColor.g/255, symbolColor.b/255, symbolColor.a];
            }
            if (color[3]<1.0) {
              setMaterialTransparent = true;
            }
            faceRangeColors.push({faceRanges:fr, "color":color});
          }
          else
          {
            faceRangeColors.push({faceRanges:fr, "color":undefined});
          }
        }

        if (this.layer.cachedDrawingInfo.color) {
          obj.setFacerangeColors(faceRangeColors, "replace");
        } else {
          obj.setFacerangeColors(faceRangeColors, "blend");
        }

        //TODO: this might fail of multiple symbols map to one engine material!
        var geoRecords = obj.getGeometryRecords();
        for (var geoRecordIdx = 0; geoRecordIdx < geoRecords.length; geoRecordIdx++) {
          var geoRecord = geoRecords[geoRecordIdx];
          for (var j = 0; j < geoRecord.materials.length; j++) {
            var mat = geoRecord.materials[j];
            var isTranspCurrent = mat.getParams().transparent;
            var opacityCurrent = mat.getParams().opacity;
            mat.metadata.symbolIsTransparent = setMaterialTransparent;
            var transpNew = this._calcEngineMaterialTransparencyParams(mat.metadata.i3sTex, mat.metadata.i3sMatParams, mat.metadata.symbolIsTransparent);
            if (isTranspCurrent!=transpNew.transparent || opacityCurrent!=transpNew.opacity) {
              mat.setParameterValues({transparent:transpNew.transparent, opacity:transpNew.opacity});
            }
          }
        }
      },

      _opacityChange: function(newValue) {
        for (var i3sMatId in this._matId2Meta) {
          for (var i3sTexId in this._matId2Meta[i3sMatId]) {
            var mat = this._matId2Meta[i3sMatId][i3sTexId].engineMat;
            var isTranspCurrent = mat.getParams().transparent;
            var opacityCurrent = mat.getParams().opacity;
            var transpNew = this._calcEngineMaterialTransparencyParams(mat.metadata.i3sTex, mat.metadata.i3sMatParams, mat.metadata.symbolIsTransparent);
            if (isTranspCurrent!=transpNew.transparent || opacityCurrent!=transpNew.opacity) {
              mat.setParameterValues({transparent:transpNew.transparent, opacity:transpNew.opacity});
            }
          }
        }
      }
    });

    function getTextureParams(domImage, texMeta) {
      var npot = false;
      var texEncoding;
      if (texMeta.encoding === I3SUtil.DDS_ENCODING_STRING) {
        texEncoding = Texture.DDS_ENCODING;
      }
      else {
        npot = !(isPowerOfTwo(domImage.width) && isPowerOfTwo(domImage.height));
      }
      return {
        mipmap: !(texMeta.atlas || npot),
        wrapClamp: texMeta.atlas || !texMeta.wrap,
        encoding: texEncoding,
        noUnpackFlip: true
      };
    }

  }
);
